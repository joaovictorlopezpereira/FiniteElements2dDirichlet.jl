var documenterSearchIndex = {"docs":
[{"location":"#Functions-Signatures-from-FiniteElements2dDirichlet","page":"Functions Signatures from FiniteElements2dDirichlet","title":"Functions Signatures from FiniteElements2dDirichlet","text":"","category":"section"},{"location":"#EQ,-LG-and-m-Initializers","page":"Functions Signatures from FiniteElements2dDirichlet","title":"EQ, LG and m Initializers","text":"","category":"section"},{"location":"","page":"Functions Signatures from FiniteElements2dDirichlet","title":"Functions Signatures from FiniteElements2dDirichlet","text":"init_LG_matrix(Nx, Ny)","category":"page"},{"location":"#FiniteElements2dDirichlet.init_LG_matrix-Tuple{Any, Any}","page":"Functions Signatures from FiniteElements2dDirichlet","title":"FiniteElements2dDirichlet.init_LG_matrix","text":"init_LG_matrix(Nx, Ny)\n\nReturn the matrix that correlates the local to the global elements.\n\nThe size of the matrix is 4×Nx*Ny\n\nArguments\n\nNx::Integer: the number of elements in the x axis.\nNy::Integer: the number of elements in the y axis.\n\nExamples\n\njulia> init_LG_matrix(2, 4)\n4×8 Matrix{Int64}:\n 1  2  4  5   7   8  10  11\n 2  3  5  6   8   9  11  12\n 5  6  8  9  11  12  14  15\n 4  5  7  8  10  11  13  14\n\n\n\n\n\n","category":"method"},{"location":"","page":"Functions Signatures from FiniteElements2dDirichlet","title":"Functions Signatures from FiniteElements2dDirichlet","text":"init_EQ_vector_and_m(Nx, Ny)","category":"page"},{"location":"#FiniteElements2dDirichlet.init_EQ_vector_and_m-Tuple{Any, Any}","page":"Functions Signatures from FiniteElements2dDirichlet","title":"FiniteElements2dDirichlet.init_EQ_vector_and_m","text":"init_EQ_vector_and_m(Nx, Ny)\n\nReturn the vector that defines which terms are important and the dominium dimension.\n\nThe size of the vector is Nx+1*Ny+1 and m is (Nx-1)*(Ny-1).\n\nArguments\n\nNx::Integer: the number of elements in the x axis.\nNy::Integer: the number of elements in the y axis.\n\nExamples\n\njulia> init_EQ_vector_and_m(2, 5)\n([5, 5, 5, 5, 1, 5, 5, 2, 5, 5, 3, 5, 5, 4, 5, 5, 5, 5], 4)\n\n\n\n\n\n","category":"method"},{"location":"#Fe-and-F-Initializers","page":"Functions Signatures from FiniteElements2dDirichlet","title":"Fe and F Initializers","text":"","category":"section"},{"location":"","page":"Functions Signatures from FiniteElements2dDirichlet","title":"Functions Signatures from FiniteElements2dDirichlet","text":"init_Fe_vector!(f, Xs, Ys, Fe, P, W)","category":"page"},{"location":"#FiniteElements2dDirichlet.init_Fe_vector!-NTuple{6, Any}","page":"Functions Signatures from FiniteElements2dDirichlet","title":"FiniteElements2dDirichlet.init_Fe_vector!","text":"init_Fe_vector!(f, Xs, Ys, Fe, P, W)\n\nMutates a given vector Fe with length 4 to become the local Fe vector.\n\nArguments\n\nf::Function: input function from the equation.\nXs::Vector{Float64}: vector of the element coordinates on the x axis.\nYs::Vector{Float64}: vector of the element coordinates on the y axis.\nFe::Vector{Float64}: vector that suffer the mutation.\nP::Vector{Float64}: vector of gauss points for numerical integration.\nW::Vector{Float64}: vector of gauss weights for numerical integration.\n\nExamples\n\njulia> Fe = zeros(4)\njulia> P, W = legendre(5)\njulia> init_Fe_vector!((x1, x2) -> 64, [0, 0.25, 0.25, 0], [0, 0, 0.25, 0.25], Fe, P, W)\njulia> Fe\n4-element Vector{Float64}:\n 0.9999999999999993\n 0.9999999999999998\n 1.0000000000000002\n 0.9999999999999998\n\n\n\n\n\n","category":"method"},{"location":"","page":"Functions Signatures from FiniteElements2dDirichlet","title":"Functions Signatures from FiniteElements2dDirichlet","text":"init_F_vector(f, X_matrix, Y_matrix, m, EQ, LG)","category":"page"},{"location":"#FiniteElements2dDirichlet.init_F_vector-NTuple{6, Any}","page":"Functions Signatures from FiniteElements2dDirichlet","title":"FiniteElements2dDirichlet.init_F_vector","text":"init_F_vector(f, X_matrix, Y_matrix, m, EQ, LG)\n\nReturn a vector F with length m for solving the differential equation.\n\nArguments\n\nf::Function: input function from the equation.\nX_matrix::Matrix{Float64}: x axis coordinates of the mesh generated by the init_mesh function.\nY_matrix::Matrix{Float64}: y axis coordinates of the mesh generated by the init_mesh function.\nm::Integer: m value generated by the EQ matrix generated by the initEQvectorandm function.\nEQ::Matrix{Integer}: EQ matrix generated by the initEQvectorandm function.\nLG::Matrix{Integer}: LG matrix generated by the initLGmatrix function.\n\nExamples\n\njulia> X, Y = init_mesh(4, 3)\njulia> LG = init_LG_matrix(4, 3)\njulia> EQ, m = init_EQ_vector_and_m(4, 3)\njulia> init_F_vector((x1, x2) -> 48, X, Y, m, EQ, LG)\n6-element Vector{Float64}:\n 3.999999999999999\n 3.999999999999999\n 3.999999999999999\n 3.999999999999999\n 3.9999999999999996\n 3.999999999999999\n\n\n\n\n\n","category":"method"},{"location":"#Ke-and-K-Initializers","page":"Functions Signatures from FiniteElements2dDirichlet","title":"Ke and K Initializers","text":"","category":"section"},{"location":"","page":"Functions Signatures from FiniteElements2dDirichlet","title":"Functions Signatures from FiniteElements2dDirichlet","text":"init_Ke_matrix!(alpha, beta, Xs, Ys, Ke, P, W)","category":"page"},{"location":"#FiniteElements2dDirichlet.init_Ke_matrix!-NTuple{7, Any}","page":"Functions Signatures from FiniteElements2dDirichlet","title":"FiniteElements2dDirichlet.init_Ke_matrix!","text":"init_Ke_matrix!(alpha, beta, Xs, Ys, Ke, P, W)\n\nMutates a given matrix Ke with dimensions 4×4 to become the local K matrix.\n\nArguments\n\nalpha::Float64: constant α from the equation.\nbeta::Float64: constant β from the equation.\nXs::Vector{Float64}: vector of the element coordinates on the x axis.\nYs::Vector{Float64}: vector of the element coordinates on the y axis.\nKe::Matrix{Float64}: matrix that suffer the mutation.\nP::Vector{Float64}: vector of gauss points for numerical integration.\nW::Vector{Float64}: vector of gauss weights for numerical integration.\n\nExamples\n\njulia> Ke = zeros(4,4)\njulia> P, W = legendre(5)\njulia> init_Ke_matrix!(6, 0, [0, 0.25, 0.25, 0], [0, 0, 0.25, 0.25], Ke, P, W)\njulia> Ke\n4×4 Matrix{Float64}:\n  4.0  -1.0  -2.0  -1.0\n -1.0   4.0  -1.0  -2.0\n -2.0  -1.0   4.0  -1.0\n -1.0  -2.0  -1.0   4.0\n\n\n\n\n\n","category":"method"},{"location":"","page":"Functions Signatures from FiniteElements2dDirichlet","title":"Functions Signatures from FiniteElements2dDirichlet","text":"init_K_matrix(alpha, beta, X_matrix, Y_matrix, m, EQ, LG)","category":"page"},{"location":"#FiniteElements2dDirichlet.init_K_matrix-NTuple{7, Any}","page":"Functions Signatures from FiniteElements2dDirichlet","title":"FiniteElements2dDirichlet.init_K_matrix","text":"init_K_matrix(alpha, beta, X_matrix, Y_matrix, m, EQ, LG)\n\nReturn a matrix K with dimensions m×m for solving the differential equation.\n\nArguments\n\nalpha::Float64: constant α from the equation.\nbeta::Float64: constant β from the equation.\nX_matrix::Matrix{Float64}: x axis coordinates of the mesh generated by the init_mesh function.\nY_matrix::Matrix{Float64}: y axis coordinates of the mesh generated by the init_mesh function.\nm::Integer: m value generated by the EQ matrix generated by the initEQvectorandm function.\nEQ::Vector{Integer}: EQ vector generated by the initEQvectorandm function.\nLG::Matrix{Integer}: LG matrix generated by the initLGmatrix function.\n\nExamples\n\njulia> X, Y = init_mesh(2,2)\njulia> EQ, m = init_EQ_vector_and_m(2,2)\njulia> LG = init_LG_matrix(2,2)\njulia> init_K_matrix(1, 1, X, Y, m, EQ, LG)\n4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:\n  2.71605   -0.320988  -0.320988  -0.330247\n -0.320988   2.71605   -0.330247  -0.320988\n -0.320988  -0.330247   2.71605   -0.320988\n -0.330247  -0.320988  -0.320988   2.71605\n\n\n\n\n\n","category":"method"},{"location":"#Mesh-Initializer","page":"Functions Signatures from FiniteElements2dDirichlet","title":"Mesh Initializer","text":"","category":"section"},{"location":"","page":"Functions Signatures from FiniteElements2dDirichlet","title":"Functions Signatures from FiniteElements2dDirichlet","text":"init_mesh(Nx, Ny; ns=false, plot=false)","category":"page"},{"location":"#FiniteElements2dDirichlet.init_mesh-Tuple{Any, Any}","page":"Functions Signatures from FiniteElements2dDirichlet","title":"FiniteElements2dDirichlet.init_mesh","text":"init_mesh(Nx, Ny; ns=false, plot=false)\n\nReturn the x and y axis mesh for solving the system.\n\nArguments\n\nNx::Integer: the number of elements in the x axis.\nNy::Integer: the number of elements in the y axis.\nns::Bool: indicates if noise should be added to the mesh.\nplot::Bool: indicates if the mesh should be plotted.\n\nExamples\n\njulia-repl julia> init_mesh(2, 3) ([0.0 0.0 0.0 0.0; 0.5 0.5 0.5 0.5; 1.0 1.0 1.0 1.0], [0.0 0.3333333333333333 0.6666666666666666 1.0; 0.0 0.3333333333333333 0.6666666666666666 1.0; 0.0 0.3333333333333333 0.6666666666666666 1.0])\n\n\n\n\n\n","category":"method"},{"location":"#System-Solver","page":"Functions Signatures from FiniteElements2dDirichlet","title":"System Solver","text":"","category":"section"},{"location":"","page":"Functions Signatures from FiniteElements2dDirichlet","title":"Functions Signatures from FiniteElements2dDirichlet","text":"solve_system(alpha, beta, f, Nx, Ny; EQLG=false, XY_matrix=false, noise=false)","category":"page"},{"location":"#FiniteElements2dDirichlet.solve_system-NTuple{5, Any}","page":"Functions Signatures from FiniteElements2dDirichlet","title":"FiniteElements2dDirichlet.solve_system","text":"solve_system(alpha, beta, f, Nx, Ny; EQLG=false, XY_matrix=false, noise=false)\n\nReturn the solution of the differential equation as a vector of the approximate solution function evaluated in the inner knots of the mesh.\n\nArguments\n\nalpha::Float64: constant α from the equation.\nbeta::Float64: constant β from the equation.\nf::Function: input function from the equation.\nNx::Integer: the number of elements in the x axis.\nNy::Integer: the number of elements in the y axis.\nEQLG::Bool: indicates if the EQ vector and LG matrix should be returned.\nXY_matrix::Bool: indicates if the X and Y matrices from the mesh should be returned.\nnoise::Bool: indicates if noise should be added to the mesh.\n\nExamples\n\njulia> solve_system(1, 1, (x, y) -> (2*pi^2 +1)*sin(pi*x)*sin(pi*y), 2, 3)\n2-element Vector{Float64}:\n 1.0040408191040564\n 1.0040408191040564\n\n\n\n\n\n","category":"method"},{"location":"#Error-Convergence","page":"Functions Signatures from FiniteElements2dDirichlet","title":"Error Convergence","text":"","category":"section"},{"location":"","page":"Functions Signatures from FiniteElements2dDirichlet","title":"Functions Signatures from FiniteElements2dDirichlet","text":"error_convergence(lb, ub, alpha, beta, u, f; see_plot=false, ns=false)","category":"page"},{"location":"#FiniteElements2dDirichlet.error_convergence-NTuple{6, Any}","page":"Functions Signatures from FiniteElements2dDirichlet","title":"FiniteElements2dDirichlet.error_convergence","text":"error_convergence(lb, ub, alpha, beta, u, f; see_plot=false, ns=false)\n\nreturn the errors of a given solution for discretizations with knots ranging from 2^lb to 2^ub. The number of knots increases in powers of 2, starting from 2^lb up to 2^ub.\n\nArguments\n\nlb::Integer: lower-bound limit for testing the error convergence.\nub::Integer: upper-bound limit for testing the error convergence.\nalpha::Float64: constant α from the equation.\nbeta::Float64: constant β from the equation.\nu::Function: solution of the equation.\nf::Function: input function from the equation.\nsee_plot::Bool: indicates if the error convergence analysis should be plotted.\nns::Bool: indicates if noise should be added to the mesh.\n\nExamples\n\njulia> error_convergence(2, 4, 1, 1, (x,y) -> sin(pi * x) * sin(pi * y), (x,y) -> (2*pi^2 + 1) * sin(pi * x) * sin(pi * y))\n3-element Vector{Float64}:\n 0.02946436125614044\n 0.007348142187147988\n 0.001836025960324437\n\n\n\n\n\n","category":"method"}]
}
