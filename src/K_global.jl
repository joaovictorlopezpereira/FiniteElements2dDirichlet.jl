"""
    init_K_matrix(alpha, beta, X_matrix, Y_matrix, m, EQ, LG)

Return a matrix ``K`` with dimensions `m×m` for solving the differential equation.

# Arguments
- `alpha::Float64`: constant α from the equation.
- `beta::Float64`: constant β from the equation.
- `X_matrix::Matrix{Float64}`: x axis coordinates of the mesh generated by the init_mesh function.
- `Y_matrix::Matrix{Float64}`: y axis coordinates of the mesh generated by the init_mesh function.
- `m::Integer`: m value generated by the EQ matrix generated by the init_EQ_vector_and_m function.
- `EQ::Vector{Integer}`: EQ vector generated by the init_EQ_vector_and_m function.
- `LG::Matrix{Integer}`: LG matrix generated by the init_LG_matrix function.

# Examples
```julia-repl
julia> X, Y = init_mesh(2,2)
julia> EQ, m = init_EQ_vector_and_m(2,2)
julia> LG = init_LG_matrix(2,2)
julia> init_K_matrix(1, 1, X, Y, m, EQ, LG)
4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:
  2.71605   -0.320988  -0.320988  -0.330247
 -0.320988   2.71605   -0.330247  -0.320988
 -0.320988  -0.330247   2.71605   -0.320988
 -0.330247  -0.320988  -0.320988   2.71605
```
"""
function init_K_matrix(alpha, beta, X_matrix, Y_matrix, m, EQ, LG)
  ne = size(LG, 2) # assuming we are using a LG (4 x ne)
  K = spzeros(m+1, m+1)
  Ke = zeros(4, 4)
  P, W = legendre(5)

  for e in 1:ne
    init_Ke_matrix!(alpha, beta, X_matrix[LG[:,e]], Y_matrix[LG[:,e]], Ke, P, W)
    for b in 1:4
      j = EQ[LG[b, e]]
      for a in 1:4
        i = EQ[LG[a, e]]
        K[i,j] += Ke[a,b]
      end
    end
  end

  return K[1:m, 1:m]
end